function [fnl, KT] = AssembleNonlinear(U, eqStructNumeric, TimePoint, N_T)
% AssembleNonlinear evaluates the nonlinear internal force and the tangent matrix
% contribution for each equation at the current time point.
%
% Inputs:
%   U              : Displacement vector of physical degrees of freedom (length nVars-2).
%   eqStructNumeric: A struct array generated by a previous script, where each 
%                    struct contains the fields: constant, linear, nonlinear, 
%                    and nVars (total number of state variables).
%   TimePoint      : Index of the current time sample point.
%   N_T            : Total number of time sample points.
%
% Outputs:
%   fnl : Internal force vector (includes nonlinear force, constant, and linear terms).
%   KT  : Tangent matrix (differentiated only with respect to the physical DOFs, 
%         i.e., the first nVars-2 state variables).

    % Assume nVars is the same for all equations in eqStructNumeric
    numEq = length(eqStructNumeric);
    nVars = eqStructNumeric(1).nVars;  
    % The number of physical degrees of freedom is nVars-2
    physDOF = nVars - 2;
    
    % Construct the full state variable vector X of length nVars
    X = zeros(1, nVars);
    X(1:physDOF) = U(:)';   
    X(physDOF+1) = sin(2*pi*(TimePoint-1)/N_T);
    X(physDOF+2) = cos(2*pi*(TimePoint-1)/N_T);
    
    % Initialize the internal force vector and the tangent matrix
    fnl = zeros(numEq, 1);
    KT  = zeros(numEq, physDOF); 
    
    % For each equation, calculate the contribution of all terms
    for i = 1:numEq
        f_val = 0;  
        
        % 1. Constant terms
        if isfield(eqStructNumeric(i), 'constant') && ~isempty(eqStructNumeric(i).constant)
            terms = eqStructNumeric(i).constant;
            for r = 1:size(terms,1)
                coeff = terms(r,1);
                exponents = terms(r,2:end); 
                % Calculate the product using vectorized operations: prod(X.^exponents)
                f_val = f_val + coeff * prod( X.^exponents );
            end
        end
        
        % 2. Linear terms
        if isfield(eqStructNumeric(i), 'linear') && ~isempty(eqStructNumeric(i).linear)
            terms = eqStructNumeric(i).linear;
            for r = 1:size(terms,1)
                coeff = terms(r,1);
                exponents = terms(r,2:end);
                f_val = f_val + coeff * prod( X.^exponents );
            end
        end
        
        % 3. Nonlinear terms and their tangent contributions
        if isfield(eqStructNumeric(i), 'nonlinear') && ~isempty(eqStructNumeric(i).nonlinear)
            terms = eqStructNumeric(i).nonlinear;
            for r = 1:size(terms,1)
                coeff = terms(r,1);
                exponents = terms(r,2:end);  
                term_val = prod( X.^exponents );
                f_val = f_val + coeff * term_val;
                
                % Calculate the partial derivative contribution for each physical DOF j 
                for j = 1:physDOF
                    if exponents(j) > 0
                        % Calculate the contribution of d/dX(j) using the power rule.
                        prod_deriv = 1;
                        for k = 1:nVars
                            if k == j
                                prod_deriv = prod_deriv * X(k)^(exponents(k)-1);
                            else
                                prod_deriv = prod_deriv * X(k)^(exponents(k));
                            end
                        end
                        dterm = coeff * exponents(j) * prod_deriv;
                        KT(i,j) = KT(i,j) + dterm;
                    end
                end
            end
        end
        % Store the internal force value for the current equation
        fnl(i) = f_val;
    end
end